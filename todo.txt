In this release

* Cleaned up IndexedSet
* scala-graph and benchmark in separate subprojects
* Rename project - Disentangle
* Parallel Dijkstra, Brandes
* Examples
* Graphs of results from benchmark

* Brandes example with enron data


* Performance graphs in Scaladoc
* comments about hotspots

* How much faster is the parallel code?

* Blog about examples



Next release

* Undirected graphs
** With Brandes' algorithm
* Louvain algorithm
* IndexedSubSet backed by BitSet

* Subgraph representation ?
* Semiring algorithm create label graph methods for label-less directed graphs, undirected graphs.

* Blog about computational stability


Later

* Brandes on an undirected graph
* Louvain clustering
* More Enron
* path representation for net.walend.graph
* translator from net.walend.graph.path to scala-graph's paths
* Prim's MST algorithm


Pulblicize

* Blog a bit

Overall
* Add more to the package doc.

Structures

* MultiPath representation (Probably a subgraph via having)
* Concurrent Graph (Or at least Graph-With-Concurrently-Modifiable-Edges)

Algorithms

* MST with Fibonacci heap
* Lazy Dijkstra. (Single-Source graph with Dijkstra's algorithm)
* A* algorithm
* Parallel queued graph minimization (will need a concurrent mutable edge graph)

Graph storage

* DynamoDB clusters


Semirings

* More Semirings

Figure out

* path representation.


---

Prim's MST algorithm

Put all the verticies in a priority queue with variable key values
Initialize all the keys to O.
Pick the root and set its key to I.
While the queue is not empty
    extract the minimum edge and node
        if the node isn't in the MST
            for each node reachable from it not currently in the MST
                if some node is closer by using this node
                    replace the key with the closer value

---


